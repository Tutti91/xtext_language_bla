/*
 * generated by Xtext
 */
package org.xtext.bot.language.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.xbase.annotations.services.XbaseWithAnnotationsGrammarAccess;
import org.eclipse.xtext.xbase.services.XbaseGrammarAccess;
import org.eclipse.xtext.xbase.services.XtypeGrammarAccess;

@Singleton
public class BlaGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class BotLanguageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BotLanguage");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBotLanguageAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cInstructionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInstructionsInstructionParserRuleCall_1_0 = (RuleCall)cInstructionsAssignment_1.eContents().get(0);
		
		////import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
		//// Language exists of Instructions
		//BotLanguage:
		//	{BotLanguage} instructions+=Instruction*;
		@Override public ParserRule getRule() { return rule; }

		//{BotLanguage} instructions+=Instruction*
		public Group getGroup() { return cGroup; }

		//{BotLanguage}
		public Action getBotLanguageAction_0() { return cBotLanguageAction_0; }

		//instructions+=Instruction*
		public Assignment getInstructionsAssignment_1() { return cInstructionsAssignment_1; }

		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_1_0() { return cInstructionsInstructionParserRuleCall_1_0; }
	}

	public class InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Instruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStartParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cProcedureParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// The Bot Language contains 6 different instructions including variables
		//// loops, conditions, functons and the username and the password for the login
		//Instruction:
		//	Start | Stop | Procedure;
		@Override public ParserRule getRule() { return rule; }

		//Start | Stop | Procedure
		public Alternatives getAlternatives() { return cAlternatives; }

		//Start
		public RuleCall getStartParserRuleCall_0() { return cStartParserRuleCall_0; }

		//Stop
		public RuleCall getStopParserRuleCall_1() { return cStopParserRuleCall_1; }

		//Procedure
		public RuleCall getProcedureParserRuleCall_2() { return cProcedureParserRuleCall_2; }
	}

	public class NotificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Notification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotificationAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cNotifyKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cNotifyKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Keyword cToKeyword_3_0 = (Keyword)cAlternatives_3.eContents().get(0);
		private final Keyword cToKeyword_3_1 = (Keyword)cAlternatives_3.eContents().get(1);
		private final Keyword cTOKeyword_3_2 = (Keyword)cAlternatives_3.eContents().get(2);
		private final Assignment cAddressAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAddressSTRINGTerminalRuleCall_4_0 = (RuleCall)cAddressAssignment_4.eContents().get(0);
		
		//// address for notification mails
		//Notification:
		//	{Notification} ("notify" | "Notify") name=STRING ("to" | "To" | "TO") address=STRING;
		@Override public ParserRule getRule() { return rule; }

		//{Notification} ("notify" | "Notify") name=STRING ("to" | "To" | "TO") address=STRING
		public Group getGroup() { return cGroup; }

		//{Notification}
		public Action getNotificationAction_0() { return cNotificationAction_0; }

		//"notify" | "Notify"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"notify"
		public Keyword getNotifyKeyword_1_0() { return cNotifyKeyword_1_0; }

		//"Notify"
		public Keyword getNotifyKeyword_1_1() { return cNotifyKeyword_1_1; }

		//name=STRING
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0() { return cNameSTRINGTerminalRuleCall_2_0; }

		//"to" | "To" | "TO"
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//"to"
		public Keyword getToKeyword_3_0() { return cToKeyword_3_0; }

		//"To"
		public Keyword getToKeyword_3_1() { return cToKeyword_3_1; }

		//"TO"
		public Keyword getTOKeyword_3_2() { return cTOKeyword_3_2; }

		//address=STRING
		public Assignment getAddressAssignment_4() { return cAddressAssignment_4; }

		//STRING
		public RuleCall getAddressSTRINGTerminalRuleCall_4_0() { return cAddressSTRINGTerminalRuleCall_4_0; }
	}

	public class StartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Start");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStartAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cStartKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cStartKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cSTARTKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//// Date evtl. mit parserrule anpassen  an Format
		//// Start for the time that starts the bot; user have to write the right form of the Type data
		//Start:
		//	{Start} ("start" | "Start" | "START") name=STRING;
		@Override public ParserRule getRule() { return rule; }

		//{Start} ("start" | "Start" | "START") name=STRING
		public Group getGroup() { return cGroup; }

		//{Start}
		public Action getStartAction_0() { return cStartAction_0; }

		//"start" | "Start" | "START"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"start"
		public Keyword getStartKeyword_1_0() { return cStartKeyword_1_0; }

		//"Start"
		public Keyword getStartKeyword_1_1() { return cStartKeyword_1_1; }

		//"START"
		public Keyword getSTARTKeyword_1_2() { return cSTARTKeyword_1_2; }

		//name=STRING
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0() { return cNameSTRINGTerminalRuleCall_2_0; }
	}

	public class StopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Stop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStopAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cStopKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cStopKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cSTOPKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		
		//// Only stop; if the Stop implementation are read then stop the bot
		//Stop:
		//	{Stop} ("stop" | "Stop" | "STOP");
		@Override public ParserRule getRule() { return rule; }

		//{Stop} ("stop" | "Stop" | "STOP")
		public Group getGroup() { return cGroup; }

		//{Stop}
		public Action getStopAction_0() { return cStopAction_0; }

		//"stop" | "Stop" | "STOP"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"stop"
		public Keyword getStopKeyword_1_0() { return cStopKeyword_1_0; }

		//"Stop"
		public Keyword getStopKeyword_1_1() { return cStopKeyword_1_1; }

		//"STOP"
		public Keyword getSTOPKeyword_1_2() { return cSTOPKeyword_1_2; }
	}

	public class ProcedureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Procedure");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConnectParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReadParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWriteParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cClickParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cVarParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cIFStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cWhileLoopParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cNotificationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cStartParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cStopParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cWaitParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		////DATE:
		////	day = DATE_FORMAT '.' month = DATE_FORMAT '.' year = YEAR ' ' hours = DATE_FORMAT ':' minutes = DATE_FORMAT ':' second = DATE_FORMAT
		////;
		////
		////
		//////
		////terminal DATE_FORMAT:
		////	(('0')('0'..'9')) | (('1'..'5')('0'..'9'))
		////;
		////
		////
		//////
		////terminal YEAR:
		////	('2'..'9')('0'..'9')('0'..'9')('0'..'9')
		////;
		//// Procedure to define the actions that the bot should do
		// Procedure:
		//	Connect | Read | Write | Click | Var | IFStatement | WhileLoop | Notification | Start | Stop | Wait;
		@Override public ParserRule getRule() { return rule; }

		//Connect | Read | Write | Click | Var | IFStatement | WhileLoop | Notification | Start | Stop | Wait
		public Alternatives getAlternatives() { return cAlternatives; }

		//Connect
		public RuleCall getConnectParserRuleCall_0() { return cConnectParserRuleCall_0; }

		//Read
		public RuleCall getReadParserRuleCall_1() { return cReadParserRuleCall_1; }

		//Write
		public RuleCall getWriteParserRuleCall_2() { return cWriteParserRuleCall_2; }

		//Click
		public RuleCall getClickParserRuleCall_3() { return cClickParserRuleCall_3; }

		//Var
		public RuleCall getVarParserRuleCall_4() { return cVarParserRuleCall_4; }

		//IFStatement
		public RuleCall getIFStatementParserRuleCall_5() { return cIFStatementParserRuleCall_5; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_6() { return cWhileLoopParserRuleCall_6; }

		//Notification
		public RuleCall getNotificationParserRuleCall_7() { return cNotificationParserRuleCall_7; }

		//Start
		public RuleCall getStartParserRuleCall_8() { return cStartParserRuleCall_8; }

		//Stop
		public RuleCall getStopParserRuleCall_9() { return cStopParserRuleCall_9; }

		//Wait
		public RuleCall getWaitParserRuleCall_10() { return cWaitParserRuleCall_10; }
	}

	public class WaitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Wait");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWaitAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cWaitKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cWaitKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameINTTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//// Wait for handle the click at's because bot action could be dedected if clicks are executed too fast
		// Wait:
		//	{Wait} ("wait" | "Wait") name=INT;
		@Override public ParserRule getRule() { return rule; }

		//{Wait} ("wait" | "Wait") name=INT
		public Group getGroup() { return cGroup; }

		//{Wait}
		public Action getWaitAction_0() { return cWaitAction_0; }

		//"wait" | "Wait"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"wait"
		public Keyword getWaitKeyword_1_0() { return cWaitKeyword_1_0; }

		//"Wait"
		public Keyword getWaitKeyword_1_1() { return cWaitKeyword_1_1; }

		//name=INT
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//INT
		public RuleCall getNameINTTerminalRuleCall_2_0() { return cNameINTTerminalRuleCall_2_0; }
	}

	public class ConnectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Connect");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConnectAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cConnectKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cConnectKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//// connecting with a URL
		//Connect:
		//	{Connect} ("connect" | "Connect") name= // URL 
		// STRING;
		@Override public ParserRule getRule() { return rule; }

		//{Connect} ("connect" | "Connect") name= // URL 
		// STRING
		public Group getGroup() { return cGroup; }

		//{Connect}
		public Action getConnectAction_0() { return cConnectAction_0; }

		//"connect" | "Connect"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"connect"
		public Keyword getConnectKeyword_1_0() { return cConnectKeyword_1_0; }

		//"Connect"
		public Keyword getConnectKeyword_1_1() { return cConnectKeyword_1_1; }

		//name= // URL 
		// STRING
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//// URL 
		// STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0() { return cNameSTRINGTerminalRuleCall_2_0; }
	}

	public class ReadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Read");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReadAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cReadAtKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cReadatKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cReadAtKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Keyword cReadAtKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		private final Keyword cReadAtKeyword_1_4 = (Keyword)cAlternatives_1.eContents().get(4);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//// read at/from a X-Path statement 
		//Read:
		//	{Read} ("read at" | "readat" | "readAt" | "Read At" | "ReadAt") name= // XPath
		//	STRING;
		@Override public ParserRule getRule() { return rule; }

		//{Read} ("read at" | "readat" | "readAt" | "Read At" | "ReadAt") name= // XPath
		//STRING
		public Group getGroup() { return cGroup; }

		//{Read}
		public Action getReadAction_0() { return cReadAction_0; }

		//"read at" | "readat" | "readAt" | "Read At" | "ReadAt"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"read at"
		public Keyword getReadAtKeyword_1_0() { return cReadAtKeyword_1_0; }

		//"readat"
		public Keyword getReadatKeyword_1_1() { return cReadatKeyword_1_1; }

		//"readAt"
		public Keyword getReadAtKeyword_1_2() { return cReadAtKeyword_1_2; }

		//"Read At"
		public Keyword getReadAtKeyword_1_3() { return cReadAtKeyword_1_3; }

		//"ReadAt"
		public Keyword getReadAtKeyword_1_4() { return cReadAtKeyword_1_4; }

		//name= // XPath
		//STRING
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//// XPath
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0() { return cNameSTRINGTerminalRuleCall_2_0; }
	}

	public class WriteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Write");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWriteAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cWriteKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cWriteKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Keyword cAtKeyword_3_0 = (Keyword)cAlternatives_3.eContents().get(0);
		private final Keyword cAtKeyword_3_1 = (Keyword)cAlternatives_3.eContents().get(1);
		private final Keyword cATKeyword_3_2 = (Keyword)cAlternatives_3.eContents().get(2);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueSTRINGTerminalRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		
		//// Write a value at a X-Path
		//Write:
		//	{Write} ("write" | "Write") name=STRING ("at" | "At" | "AT") value=STRING;
		@Override public ParserRule getRule() { return rule; }

		//{Write} ("write" | "Write") name=STRING ("at" | "At" | "AT") value=STRING
		public Group getGroup() { return cGroup; }

		//{Write}
		public Action getWriteAction_0() { return cWriteAction_0; }

		//"write" | "Write"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"write"
		public Keyword getWriteKeyword_1_0() { return cWriteKeyword_1_0; }

		//"Write"
		public Keyword getWriteKeyword_1_1() { return cWriteKeyword_1_1; }

		//name=STRING
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0() { return cNameSTRINGTerminalRuleCall_2_0; }

		//"at" | "At" | "AT"
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//"at"
		public Keyword getAtKeyword_3_0() { return cAtKeyword_3_0; }

		//"At"
		public Keyword getAtKeyword_3_1() { return cAtKeyword_3_1; }

		//"AT"
		public Keyword getATKeyword_3_2() { return cATKeyword_3_2; }

		//value=STRING
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_4_0() { return cValueSTRINGTerminalRuleCall_4_0; }
	}

	public class ClickElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Click");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cClickAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cClickAtKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cClickatKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cClickAtKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Keyword cClickAtKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		private final Keyword cClickAtKeyword_1_4 = (Keyword)cAlternatives_1.eContents().get(4);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//// Click at a X-Path
		//Click:
		//	{Click} ("click at" | "clickat" | "clickAt" | "Click At" | "ClickAt") name=STRING;
		@Override public ParserRule getRule() { return rule; }

		//{Click} ("click at" | "clickat" | "clickAt" | "Click At" | "ClickAt") name=STRING
		public Group getGroup() { return cGroup; }

		//{Click}
		public Action getClickAction_0() { return cClickAction_0; }

		//"click at" | "clickat" | "clickAt" | "Click At" | "ClickAt"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"click at"
		public Keyword getClickAtKeyword_1_0() { return cClickAtKeyword_1_0; }

		//"clickat"
		public Keyword getClickatKeyword_1_1() { return cClickatKeyword_1_1; }

		//"clickAt"
		public Keyword getClickAtKeyword_1_2() { return cClickAtKeyword_1_2; }

		//"Click At"
		public Keyword getClickAtKeyword_1_3() { return cClickAtKeyword_1_3; }

		//"ClickAt"
		public Keyword getClickAtKeyword_1_4() { return cClickAtKeyword_1_4; }

		//name=STRING
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0() { return cNameSTRINGTerminalRuleCall_2_0; }
	}

	public class VarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Var");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVarAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cVarKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cVarKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cVARKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueReadParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		
		//// A Variable for defining a ReadAt such as var a = read at 'xpath'
		//// It is comfortable for the user to use variables in if or while 
		//Var:
		//	{Var} ("var" | "Var" | "VAR") name=ID "=" value=Read;
		@Override public ParserRule getRule() { return rule; }

		//{Var} ("var" | "Var" | "VAR") name=ID "=" value=Read
		public Group getGroup() { return cGroup; }

		//{Var}
		public Action getVarAction_0() { return cVarAction_0; }

		//"var" | "Var" | "VAR"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"var"
		public Keyword getVarKeyword_1_0() { return cVarKeyword_1_0; }

		//"Var"
		public Keyword getVarKeyword_1_1() { return cVarKeyword_1_1; }

		//"VAR"
		public Keyword getVARKeyword_1_2() { return cVARKeyword_1_2; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//value=Read
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//Read
		public RuleCall getValueReadParserRuleCall_4_0() { return cValueReadParserRuleCall_4_0; }
	}

	public class IFStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IFStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cIfKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cIFKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final Assignment cIfAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIfIfExpressionParserRuleCall_1_0 = (RuleCall)cIfAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cThenKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cThenKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Keyword cTHENKeyword_2_2 = (Keyword)cAlternatives_2.eContents().get(2);
		private final Assignment cThenAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenBlockParserRuleCall_3_0 = (RuleCall)cThenAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_4_0 = (Alternatives)cGroup_4.eContents().get(0);
		private final Keyword cElseKeyword_4_0_0 = (Keyword)cAlternatives_4_0.eContents().get(0);
		private final Keyword cElseKeyword_4_0_1 = (Keyword)cAlternatives_4_0.eContents().get(1);
		private final Keyword cELSEKeyword_4_0_2 = (Keyword)cAlternatives_4_0.eContents().get(2);
		private final Assignment cElseAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cElseBlockParserRuleCall_4_1_0 = (RuleCall)cElseAssignment_4_1.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Keyword cEndifKeyword_5_0 = (Keyword)cAlternatives_5.eContents().get(0);
		private final Keyword cEndifKeyword_5_1 = (Keyword)cAlternatives_5.eContents().get(1);
		private final Keyword cEndIfKeyword_5_2 = (Keyword)cAlternatives_5.eContents().get(2);
		private final Keyword cENDIFKeyword_5_3 = (Keyword)cAlternatives_5.eContents().get(3);
		
		//// If-statement for a normal if such as if ... else (optional) ... endif
		//IFStatement:
		//	("if" | "If" | "IF") if=IfExpression ("then" | "Then" | "THEN") then+=Block* (("else" | "Else" | "ELSE")
		//	else+=Block*)? ("endif" | "Endif" | "EndIf" | "ENDIF");
		@Override public ParserRule getRule() { return rule; }

		//("if" | "If" | "IF") if=IfExpression ("then" | "Then" | "THEN") then+=Block* (("else" | "Else" | "ELSE") else+=Block*)?
		//("endif" | "Endif" | "EndIf" | "ENDIF")
		public Group getGroup() { return cGroup; }

		//"if" | "If" | "IF"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"if"
		public Keyword getIfKeyword_0_0() { return cIfKeyword_0_0; }

		//"If"
		public Keyword getIfKeyword_0_1() { return cIfKeyword_0_1; }

		//"IF"
		public Keyword getIFKeyword_0_2() { return cIFKeyword_0_2; }

		//if=IfExpression
		public Assignment getIfAssignment_1() { return cIfAssignment_1; }

		//IfExpression
		public RuleCall getIfIfExpressionParserRuleCall_1_0() { return cIfIfExpressionParserRuleCall_1_0; }

		//"then" | "Then" | "THEN"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"then"
		public Keyword getThenKeyword_2_0() { return cThenKeyword_2_0; }

		//"Then"
		public Keyword getThenKeyword_2_1() { return cThenKeyword_2_1; }

		//"THEN"
		public Keyword getTHENKeyword_2_2() { return cTHENKeyword_2_2; }

		//then+=Block*
		public Assignment getThenAssignment_3() { return cThenAssignment_3; }

		//Block
		public RuleCall getThenBlockParserRuleCall_3_0() { return cThenBlockParserRuleCall_3_0; }

		//(("else" | "Else" | "ELSE") else+=Block*)?
		public Group getGroup_4() { return cGroup_4; }

		//"else" | "Else" | "ELSE"
		public Alternatives getAlternatives_4_0() { return cAlternatives_4_0; }

		//"else"
		public Keyword getElseKeyword_4_0_0() { return cElseKeyword_4_0_0; }

		//"Else"
		public Keyword getElseKeyword_4_0_1() { return cElseKeyword_4_0_1; }

		//"ELSE"
		public Keyword getELSEKeyword_4_0_2() { return cELSEKeyword_4_0_2; }

		//else+=Block*
		public Assignment getElseAssignment_4_1() { return cElseAssignment_4_1; }

		//Block
		public RuleCall getElseBlockParserRuleCall_4_1_0() { return cElseBlockParserRuleCall_4_1_0; }

		//"endif" | "Endif" | "EndIf" | "ENDIF"
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//"endif"
		public Keyword getEndifKeyword_5_0() { return cEndifKeyword_5_0; }

		//"Endif"
		public Keyword getEndifKeyword_5_1() { return cEndifKeyword_5_1; }

		//"EndIf"
		public Keyword getEndIfKeyword_5_2() { return cEndIfKeyword_5_2; }

		//"ENDIF"
		public Keyword getENDIFKeyword_5_3() { return cENDIFKeyword_5_3; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBlockAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cActionAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cActionWriteParserRuleCall_0_1_0 = (RuleCall)cActionAssignment_0_1.eContents().get(0);
		private final RuleCall cReadParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cClickParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVarParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIFStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cWhileLoopParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNotificationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cWaitParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cStopParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cStartParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//// Expression for a then-expression
		//Block:
		//	{Block} action=Write | Read | Click | Var | IFStatement | WhileLoop | Notification | Wait | Stop | Start;
		@Override public ParserRule getRule() { return rule; }

		//{Block} action=Write | Read | Click | Var | IFStatement | WhileLoop | Notification | Wait | Stop | Start
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Block} action=Write
		public Group getGroup_0() { return cGroup_0; }

		//{Block}
		public Action getBlockAction_0_0() { return cBlockAction_0_0; }

		//action=Write
		public Assignment getActionAssignment_0_1() { return cActionAssignment_0_1; }

		//Write
		public RuleCall getActionWriteParserRuleCall_0_1_0() { return cActionWriteParserRuleCall_0_1_0; }

		//Read
		public RuleCall getReadParserRuleCall_1() { return cReadParserRuleCall_1; }

		//Click
		public RuleCall getClickParserRuleCall_2() { return cClickParserRuleCall_2; }

		//Var
		public RuleCall getVarParserRuleCall_3() { return cVarParserRuleCall_3; }

		//IFStatement
		public RuleCall getIFStatementParserRuleCall_4() { return cIFStatementParserRuleCall_4; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_5() { return cWhileLoopParserRuleCall_5; }

		//Notification
		public RuleCall getNotificationParserRuleCall_6() { return cNotificationParserRuleCall_6; }

		//Wait
		public RuleCall getWaitParserRuleCall_7() { return cWaitParserRuleCall_7; }

		//Stop
		public RuleCall getStopParserRuleCall_8() { return cStopParserRuleCall_8; }

		//Start
		public RuleCall getStartParserRuleCall_9() { return cStartParserRuleCall_9; }
	}

	public class IfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfAndExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIfOrExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIfCompareExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// begin of the IFExpression Rules including And-, Or- & Compare-Expressions to manage a right if statement
		//
		//IfExpression:
		//	IfAndExpression | IfOrExpression | IfCompareExpression;
		@Override public ParserRule getRule() { return rule; }

		//IfAndExpression | IfOrExpression | IfCompareExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//IfAndExpression
		public RuleCall getIfAndExpressionParserRuleCall_0() { return cIfAndExpressionParserRuleCall_0; }

		//IfOrExpression
		public RuleCall getIfOrExpressionParserRuleCall_1() { return cIfOrExpressionParserRuleCall_1; }

		//IfCompareExpression
		public RuleCall getIfCompareExpressionParserRuleCall_2() { return cIfCompareExpressionParserRuleCall_2; }
	}

	public class IfAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfAndExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cLeftFeatureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftFeatureIfCompareExpressionParserRuleCall_1_0 = (RuleCall)cLeftFeatureAssignment_1.eContents().get(0);
		private final Assignment cAndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAndAndOperantParserRuleCall_2_0 = (RuleCall)cAndAssignment_2.eContents().get(0);
		private final Assignment cRightFeatureAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightFeatureIfExpressionParserRuleCall_3_0 = (RuleCall)cRightFeatureAssignment_3.eContents().get(0);
		
		//// And
		// IfAndExpression:
		//	{IfAndExpression} leftFeature=IfCompareExpression and=andOperant rightFeature=IfExpression;
		@Override public ParserRule getRule() { return rule; }

		//{IfAndExpression} leftFeature=IfCompareExpression and=andOperant rightFeature=IfExpression
		public Group getGroup() { return cGroup; }

		//{IfAndExpression}
		public Action getIfAndExpressionAction_0() { return cIfAndExpressionAction_0; }

		//leftFeature=IfCompareExpression
		public Assignment getLeftFeatureAssignment_1() { return cLeftFeatureAssignment_1; }

		//IfCompareExpression
		public RuleCall getLeftFeatureIfCompareExpressionParserRuleCall_1_0() { return cLeftFeatureIfCompareExpressionParserRuleCall_1_0; }

		//and=andOperant
		public Assignment getAndAssignment_2() { return cAndAssignment_2; }

		//andOperant
		public RuleCall getAndAndOperantParserRuleCall_2_0() { return cAndAndOperantParserRuleCall_2_0; }

		//rightFeature=IfExpression
		public Assignment getRightFeatureAssignment_3() { return cRightFeatureAssignment_3; }

		//IfExpression
		public RuleCall getRightFeatureIfExpressionParserRuleCall_3_0() { return cRightFeatureIfExpressionParserRuleCall_3_0; }
	}

	public class AndOperantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "andOperant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAmpersandAmpersandKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAmpersandKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAndKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAndKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cANDKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		////And
		// andOperant:
		//	"&&" | "&" | "and" | "And" | "AND";
		@Override public ParserRule getRule() { return rule; }

		//"&&" | "&" | "and" | "And" | "AND"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_0() { return cAmpersandAmpersandKeyword_0; }

		//"&"
		public Keyword getAmpersandKeyword_1() { return cAmpersandKeyword_1; }

		//"and"
		public Keyword getAndKeyword_2() { return cAndKeyword_2; }

		//"And"
		public Keyword getAndKeyword_3() { return cAndKeyword_3; }

		//"AND"
		public Keyword getANDKeyword_4() { return cANDKeyword_4; }
	}

	public class IfOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftFeatureAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftFeatureIfCompareExpressionParserRuleCall_0_0 = (RuleCall)cLeftFeatureAssignment_0.eContents().get(0);
		private final Assignment cOrAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOrOrOperantParserRuleCall_1_0 = (RuleCall)cOrAssignment_1.eContents().get(0);
		private final Assignment cRightFeatureAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightFeatureIfCompareExpressionParserRuleCall_2_0 = (RuleCall)cRightFeatureAssignment_2.eContents().get(0);
		
		////OR
		// IfOrExpression:
		//	leftFeature=IfCompareExpression or=orOperant rightFeature=IfCompareExpression;
		@Override public ParserRule getRule() { return rule; }

		//leftFeature=IfCompareExpression or=orOperant rightFeature=IfCompareExpression
		public Group getGroup() { return cGroup; }

		//leftFeature=IfCompareExpression
		public Assignment getLeftFeatureAssignment_0() { return cLeftFeatureAssignment_0; }

		//IfCompareExpression
		public RuleCall getLeftFeatureIfCompareExpressionParserRuleCall_0_0() { return cLeftFeatureIfCompareExpressionParserRuleCall_0_0; }

		//or=orOperant
		public Assignment getOrAssignment_1() { return cOrAssignment_1; }

		//orOperant
		public RuleCall getOrOrOperantParserRuleCall_1_0() { return cOrOrOperantParserRuleCall_1_0; }

		//rightFeature=IfCompareExpression
		public Assignment getRightFeatureAssignment_2() { return cRightFeatureAssignment_2; }

		//IfCompareExpression
		public RuleCall getRightFeatureIfCompareExpressionParserRuleCall_2_0() { return cRightFeatureIfCompareExpressionParserRuleCall_2_0; }
	}

	public class OrOperantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "orOperant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cVerticalLineVerticalLineKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOrKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cOrKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cORKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		////OR
		// orOperant:
		//	"||" | "|" | "or" | "Or" | "OR";
		@Override public ParserRule getRule() { return rule; }

		//"||" | "|" | "or" | "Or" | "OR"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_0() { return cVerticalLineVerticalLineKeyword_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1() { return cVerticalLineKeyword_1; }

		//"or"
		public Keyword getOrKeyword_2() { return cOrKeyword_2; }

		//"Or"
		public Keyword getOrKeyword_3() { return cOrKeyword_3; }

		//"OR"
		public Keyword getORKeyword_4() { return cORKeyword_4; }
	}

	public class IfCompareExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfCompareExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftFeatureAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftFeatureCompareFeatureParserRuleCall_0_0 = (RuleCall)cLeftFeatureAssignment_0.eContents().get(0);
		private final Assignment cCompareOperantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCompareOperantMultiCompareOperantParserRuleCall_1_0 = (RuleCall)cCompareOperantAssignment_1.eContents().get(0);
		private final Assignment cRightFeatureAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightFeatureCompareValueParserRuleCall_2_0 = (RuleCall)cRightFeatureAssignment_2.eContents().get(0);
		
		////Compare
		// IfCompareExpression:
		//	leftFeature=CompareFeature compareOperant=MultiCompareOperant rightFeature=CompareValue;
		@Override public ParserRule getRule() { return rule; }

		//leftFeature=CompareFeature compareOperant=MultiCompareOperant rightFeature=CompareValue
		public Group getGroup() { return cGroup; }

		//leftFeature=CompareFeature
		public Assignment getLeftFeatureAssignment_0() { return cLeftFeatureAssignment_0; }

		//CompareFeature
		public RuleCall getLeftFeatureCompareFeatureParserRuleCall_0_0() { return cLeftFeatureCompareFeatureParserRuleCall_0_0; }

		//compareOperant=MultiCompareOperant
		public Assignment getCompareOperantAssignment_1() { return cCompareOperantAssignment_1; }

		//MultiCompareOperant
		public RuleCall getCompareOperantMultiCompareOperantParserRuleCall_1_0() { return cCompareOperantMultiCompareOperantParserRuleCall_1_0; }

		//rightFeature=CompareValue
		public Assignment getRightFeatureAssignment_2() { return cRightFeatureAssignment_2; }

		//CompareValue
		public RuleCall getRightFeatureCompareValueParserRuleCall_2_0() { return cRightFeatureCompareValueParserRuleCall_2_0; }
	}

	public class CompareValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompareValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cCompareValueAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMathematicalInstructionsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cReadParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Assignment cVariableValueAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final CrossReference cVariableValueVarCrossReference_4_0 = (CrossReference)cVariableValueAssignment_4.eContents().get(0);
		private final RuleCall cVariableValueVarIDTerminalRuleCall_4_0_1 = (RuleCall)cVariableValueVarCrossReference_4_0.eContents().get(1);
		
		////Compar
		// CompareValue:
		//	{CompareValue} INT | STRING | MathematicalInstructions | Read | variableValue=[Var];
		@Override public ParserRule getRule() { return rule; }

		//{CompareValue} INT | STRING | MathematicalInstructions | Read | variableValue=[Var]
		public Alternatives getAlternatives() { return cAlternatives; }

		//{CompareValue} INT
		public Group getGroup_0() { return cGroup_0; }

		//{CompareValue}
		public Action getCompareValueAction_0_0() { return cCompareValueAction_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1() { return cSTRINGTerminalRuleCall_1; }

		//MathematicalInstructions
		public RuleCall getMathematicalInstructionsParserRuleCall_2() { return cMathematicalInstructionsParserRuleCall_2; }

		//Read
		public RuleCall getReadParserRuleCall_3() { return cReadParserRuleCall_3; }

		//variableValue=[Var]
		public Assignment getVariableValueAssignment_4() { return cVariableValueAssignment_4; }

		//[Var]
		public CrossReference getVariableValueVarCrossReference_4_0() { return cVariableValueVarCrossReference_4_0; }

		//ID
		public RuleCall getVariableValueVarIDTerminalRuleCall_4_0_1() { return cVariableValueVarIDTerminalRuleCall_4_0_1; }
	}

	public class MultiCompareOperantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiCompareOperant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGreaterThanSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cGreaterThanSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cExclamationMarkEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		
		////Compare
		// MultiCompareOperant:
		//	"<" | "<=" | "==" | "=" | ">=" | ">" | "!=";
		@Override public ParserRule getRule() { return rule; }

		//"<" | "<=" | "==" | "=" | ">=" | ">" | "!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1() { return cLessThanSignEqualsSignKeyword_1; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_2() { return cEqualsSignEqualsSignKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_4() { return cGreaterThanSignEqualsSignKeyword_4; }

		//">"
		public Keyword getGreaterThanSignKeyword_5() { return cGreaterThanSignKeyword_5; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_6() { return cExclamationMarkEqualsSignKeyword_6; }
	}

	public class CompareFeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompareFeature");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cCompareFeatureAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMathematicalInstructionsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cReadParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Assignment cVariableFeatureAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final CrossReference cVariableFeatureVarCrossReference_4_0 = (CrossReference)cVariableFeatureAssignment_4.eContents().get(0);
		private final RuleCall cVariableFeatureVarIDTerminalRuleCall_4_0_1 = (RuleCall)cVariableFeatureVarCrossReference_4_0.eContents().get(1);
		
		////Compare
		// CompareFeature:
		//	{CompareFeature} INT | STRING | MathematicalInstructions | Read | variableFeature=[Var];
		@Override public ParserRule getRule() { return rule; }

		//{CompareFeature} INT | STRING | MathematicalInstructions | Read | variableFeature=[Var]
		public Alternatives getAlternatives() { return cAlternatives; }

		//{CompareFeature} INT
		public Group getGroup_0() { return cGroup_0; }

		//{CompareFeature}
		public Action getCompareFeatureAction_0_0() { return cCompareFeatureAction_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1() { return cSTRINGTerminalRuleCall_1; }

		//MathematicalInstructions
		public RuleCall getMathematicalInstructionsParserRuleCall_2() { return cMathematicalInstructionsParserRuleCall_2; }

		//Read
		public RuleCall getReadParserRuleCall_3() { return cReadParserRuleCall_3; }

		//variableFeature=[Var]
		public Assignment getVariableFeatureAssignment_4() { return cVariableFeatureAssignment_4; }

		//[Var]
		public CrossReference getVariableFeatureVarCrossReference_4_0() { return cVariableFeatureVarCrossReference_4_0; }

		//ID
		public RuleCall getVariableFeatureVarIDTerminalRuleCall_4_0_1() { return cVariableFeatureVarIDTerminalRuleCall_4_0_1; }
	}

	public class MathematicalInstructionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MathematicalInstructions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubtractionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDivisionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Mathematical Instructions
		//MathematicalInstructions:
		//	Addition | Subtraction | Multiplication | Division;
		@Override public ParserRule getRule() { return rule; }

		//Addition | Subtraction | Multiplication | Division
		public Alternatives getAlternatives() { return cAlternatives; }

		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }

		//Subtraction
		public RuleCall getSubtractionParserRuleCall_1() { return cSubtractionParserRuleCall_1; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_2() { return cMultiplicationParserRuleCall_2; }

		//Division
		public RuleCall getDivisionParserRuleCall_3() { return cDivisionParserRuleCall_3; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAdditionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueLeftMathValue1ParserRuleCall_1_0 = (RuleCall)cValueLeftAssignment_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueRightMathValue2ParserRuleCall_3_0 = (RuleCall)cValueRightAssignment_3.eContents().get(0);
		
		////Add
		//Addition:
		//	{Addition} valueLeft=MathValue1 "+" valueRight=MathValue2;
		@Override public ParserRule getRule() { return rule; }

		//{Addition} valueLeft=MathValue1 "+" valueRight=MathValue2
		public Group getGroup() { return cGroup; }

		//{Addition}
		public Action getAdditionAction_0() { return cAdditionAction_0; }

		//valueLeft=MathValue1
		public Assignment getValueLeftAssignment_1() { return cValueLeftAssignment_1; }

		//MathValue1
		public RuleCall getValueLeftMathValue1ParserRuleCall_1_0() { return cValueLeftMathValue1ParserRuleCall_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_2() { return cPlusSignKeyword_2; }

		//valueRight=MathValue2
		public Assignment getValueRightAssignment_3() { return cValueRightAssignment_3; }

		//MathValue2
		public RuleCall getValueRightMathValue2ParserRuleCall_3_0() { return cValueRightMathValue2ParserRuleCall_3_0; }
	}

	public class SubtractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Subtraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSubtractionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueLeftMathValue1ParserRuleCall_1_0 = (RuleCall)cValueLeftAssignment_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueRightMathValue2ParserRuleCall_3_0 = (RuleCall)cValueRightAssignment_3.eContents().get(0);
		
		////Sub
		//Subtraction:
		//	{Subtraction} valueLeft=MathValue1 "-" valueRight=MathValue2;
		@Override public ParserRule getRule() { return rule; }

		//{Subtraction} valueLeft=MathValue1 "-" valueRight=MathValue2
		public Group getGroup() { return cGroup; }

		//{Subtraction}
		public Action getSubtractionAction_0() { return cSubtractionAction_0; }

		//valueLeft=MathValue1
		public Assignment getValueLeftAssignment_1() { return cValueLeftAssignment_1; }

		//MathValue1
		public RuleCall getValueLeftMathValue1ParserRuleCall_1_0() { return cValueLeftMathValue1ParserRuleCall_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_2() { return cHyphenMinusKeyword_2; }

		//valueRight=MathValue2
		public Assignment getValueRightAssignment_3() { return cValueRightAssignment_3; }

		//MathValue2
		public RuleCall getValueRightMathValue2ParserRuleCall_3_0() { return cValueRightMathValue2ParserRuleCall_3_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMultiplicationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueLeftMathValue1ParserRuleCall_1_0 = (RuleCall)cValueLeftAssignment_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueRightMathValue2ParserRuleCall_3_0 = (RuleCall)cValueRightAssignment_3.eContents().get(0);
		
		////Multiplicate
		//Multiplication:
		//	{Multiplication} valueLeft=MathValue1 "*" valueRight=MathValue2;
		@Override public ParserRule getRule() { return rule; }

		//{Multiplication} valueLeft=MathValue1 "*" valueRight=MathValue2
		public Group getGroup() { return cGroup; }

		//{Multiplication}
		public Action getMultiplicationAction_0() { return cMultiplicationAction_0; }

		//valueLeft=MathValue1
		public Assignment getValueLeftAssignment_1() { return cValueLeftAssignment_1; }

		//MathValue1
		public RuleCall getValueLeftMathValue1ParserRuleCall_1_0() { return cValueLeftMathValue1ParserRuleCall_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_2() { return cAsteriskKeyword_2; }

		//valueRight=MathValue2
		public Assignment getValueRightAssignment_3() { return cValueRightAssignment_3; }

		//MathValue2
		public RuleCall getValueRightMathValue2ParserRuleCall_3_0() { return cValueRightMathValue2ParserRuleCall_3_0; }
	}

	public class DivisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Division");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDivisionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueLeftMathValue1ParserRuleCall_1_0 = (RuleCall)cValueLeftAssignment_1.eContents().get(0);
		private final Keyword cSolidusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueRightMathValue2ParserRuleCall_3_0 = (RuleCall)cValueRightAssignment_3.eContents().get(0);
		
		////Divide
		//Division:
		//	{Division} valueLeft=MathValue1 "/" valueRight=MathValue2;
		@Override public ParserRule getRule() { return rule; }

		//{Division} valueLeft=MathValue1 "/" valueRight=MathValue2
		public Group getGroup() { return cGroup; }

		//{Division}
		public Action getDivisionAction_0() { return cDivisionAction_0; }

		//valueLeft=MathValue1
		public Assignment getValueLeftAssignment_1() { return cValueLeftAssignment_1; }

		//MathValue1
		public RuleCall getValueLeftMathValue1ParserRuleCall_1_0() { return cValueLeftMathValue1ParserRuleCall_1_0; }

		//"/"
		public Keyword getSolidusKeyword_2() { return cSolidusKeyword_2; }

		//valueRight=MathValue2
		public Assignment getValueRightAssignment_3() { return cValueRightAssignment_3; }

		//MathValue2
		public RuleCall getValueRightMathValue2ParserRuleCall_3_0() { return cValueRightMathValue2ParserRuleCall_3_0; }
	}

	public class MathValue1Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MathValue1");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cMathValue1Action_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cReadParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVarParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////Mathematical Value almost left
		// MathValue1:
		//	{MathValue1} INT | Read | Var;
		@Override public ParserRule getRule() { return rule; }

		//{MathValue1} INT | Read | Var
		public Alternatives getAlternatives() { return cAlternatives; }

		//{MathValue1} INT
		public Group getGroup_0() { return cGroup_0; }

		//{MathValue1}
		public Action getMathValue1Action_0_0() { return cMathValue1Action_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }

		//Read
		public RuleCall getReadParserRuleCall_1() { return cReadParserRuleCall_1; }

		//Var
		public RuleCall getVarParserRuleCall_2() { return cVarParserRuleCall_2; }
	}

	public class MathValue2Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MathValue2");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cMathValue2Action_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cReadParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVarParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////Mathematical Value almost right
		//MathValue2:
		//	{MathValue2} INT | Read | Var;
		@Override public ParserRule getRule() { return rule; }

		//{MathValue2} INT | Read | Var
		public Alternatives getAlternatives() { return cAlternatives; }

		//{MathValue2} INT
		public Group getGroup_0() { return cGroup_0; }

		//{MathValue2}
		public Action getMathValue2Action_0_0() { return cMathValue2Action_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }

		//Read
		public RuleCall getReadParserRuleCall_1() { return cReadParserRuleCall_1; }

		//Var
		public RuleCall getVarParserRuleCall_2() { return cVarParserRuleCall_2; }
	}

	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cWhileKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cWHILEKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final Assignment cWhileAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhileIfExpressionParserRuleCall_1_0 = (RuleCall)cWhileAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cLoopKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cLoopKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Keyword cLOOPKeyword_2_2 = (Keyword)cAlternatives_2.eContents().get(2);
		private final Assignment cDoLoopAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDoLoopBlockParserRuleCall_3_0 = (RuleCall)cDoLoopAssignment_3.eContents().get(0);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Keyword cEndloopKeyword_4_0 = (Keyword)cAlternatives_4.eContents().get(0);
		private final Keyword cEndloopKeyword_4_1 = (Keyword)cAlternatives_4.eContents().get(1);
		private final Keyword cEndLoopKeyword_4_2 = (Keyword)cAlternatives_4.eContents().get(2);
		private final Keyword cENDLOOPKeyword_4_3 = (Keyword)cAlternatives_4.eContents().get(3);
		
		//// While loop Statement for executing a loop with a IfExpression
		//WhileLoop:
		//	("while" | "While" | "WHILE") while=IfExpression ("loop" | "Loop" | "LOOP") doLoop+=Block* ("endloop" | "Endloop" |
		//	"EndLoop" | "ENDLOOP");
		@Override public ParserRule getRule() { return rule; }

		//("while" | "While" | "WHILE") while=IfExpression ("loop" | "Loop" | "LOOP") doLoop+=Block* ("endloop" | "Endloop" |
		//"EndLoop" | "ENDLOOP")
		public Group getGroup() { return cGroup; }

		//"while" | "While" | "WHILE"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"while"
		public Keyword getWhileKeyword_0_0() { return cWhileKeyword_0_0; }

		//"While"
		public Keyword getWhileKeyword_0_1() { return cWhileKeyword_0_1; }

		//"WHILE"
		public Keyword getWHILEKeyword_0_2() { return cWHILEKeyword_0_2; }

		//while=IfExpression
		public Assignment getWhileAssignment_1() { return cWhileAssignment_1; }

		//IfExpression
		public RuleCall getWhileIfExpressionParserRuleCall_1_0() { return cWhileIfExpressionParserRuleCall_1_0; }

		//"loop" | "Loop" | "LOOP"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"loop"
		public Keyword getLoopKeyword_2_0() { return cLoopKeyword_2_0; }

		//"Loop"
		public Keyword getLoopKeyword_2_1() { return cLoopKeyword_2_1; }

		//"LOOP"
		public Keyword getLOOPKeyword_2_2() { return cLOOPKeyword_2_2; }

		//doLoop+=Block*
		public Assignment getDoLoopAssignment_3() { return cDoLoopAssignment_3; }

		//Block
		public RuleCall getDoLoopBlockParserRuleCall_3_0() { return cDoLoopBlockParserRuleCall_3_0; }

		//"endloop" | "Endloop" | "EndLoop" | "ENDLOOP"
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//"endloop"
		public Keyword getEndloopKeyword_4_0() { return cEndloopKeyword_4_0; }

		//"Endloop"
		public Keyword getEndloopKeyword_4_1() { return cEndloopKeyword_4_1; }

		//"EndLoop"
		public Keyword getEndLoopKeyword_4_2() { return cEndLoopKeyword_4_2; }

		//"ENDLOOP"
		public Keyword getENDLOOPKeyword_4_3() { return cENDLOOPKeyword_4_3; }
	}
	
	
	private final BotLanguageElements pBotLanguage;
	private final InstructionElements pInstruction;
	private final NotificationElements pNotification;
	private final StartElements pStart;
	private final StopElements pStop;
	private final ProcedureElements pProcedure;
	private final WaitElements pWait;
	private final ConnectElements pConnect;
	private final ReadElements pRead;
	private final WriteElements pWrite;
	private final ClickElements pClick;
	private final VarElements pVar;
	private final IFStatementElements pIFStatement;
	private final BlockElements pBlock;
	private final IfExpressionElements pIfExpression;
	private final IfAndExpressionElements pIfAndExpression;
	private final AndOperantElements pAndOperant;
	private final IfOrExpressionElements pIfOrExpression;
	private final OrOperantElements pOrOperant;
	private final IfCompareExpressionElements pIfCompareExpression;
	private final CompareValueElements pCompareValue;
	private final MultiCompareOperantElements pMultiCompareOperant;
	private final CompareFeatureElements pCompareFeature;
	private final MathematicalInstructionsElements pMathematicalInstructions;
	private final AdditionElements pAddition;
	private final SubtractionElements pSubtraction;
	private final MultiplicationElements pMultiplication;
	private final DivisionElements pDivision;
	private final MathValue1Elements pMathValue1;
	private final MathValue2Elements pMathValue2;
	private final WhileLoopElements pWhileLoop;
	
	private final Grammar grammar;

	private final XbaseWithAnnotationsGrammarAccess gaXbaseWithAnnotations;

	@Inject
	public BlaGrammarAccess(GrammarProvider grammarProvider,
		XbaseWithAnnotationsGrammarAccess gaXbaseWithAnnotations) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaXbaseWithAnnotations = gaXbaseWithAnnotations;
		this.pBotLanguage = new BotLanguageElements();
		this.pInstruction = new InstructionElements();
		this.pNotification = new NotificationElements();
		this.pStart = new StartElements();
		this.pStop = new StopElements();
		this.pProcedure = new ProcedureElements();
		this.pWait = new WaitElements();
		this.pConnect = new ConnectElements();
		this.pRead = new ReadElements();
		this.pWrite = new WriteElements();
		this.pClick = new ClickElements();
		this.pVar = new VarElements();
		this.pIFStatement = new IFStatementElements();
		this.pBlock = new BlockElements();
		this.pIfExpression = new IfExpressionElements();
		this.pIfAndExpression = new IfAndExpressionElements();
		this.pAndOperant = new AndOperantElements();
		this.pIfOrExpression = new IfOrExpressionElements();
		this.pOrOperant = new OrOperantElements();
		this.pIfCompareExpression = new IfCompareExpressionElements();
		this.pCompareValue = new CompareValueElements();
		this.pMultiCompareOperant = new MultiCompareOperantElements();
		this.pCompareFeature = new CompareFeatureElements();
		this.pMathematicalInstructions = new MathematicalInstructionsElements();
		this.pAddition = new AdditionElements();
		this.pSubtraction = new SubtractionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pDivision = new DivisionElements();
		this.pMathValue1 = new MathValue1Elements();
		this.pMathValue2 = new MathValue2Elements();
		this.pWhileLoop = new WhileLoopElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.bot.language.Bla".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public XbaseWithAnnotationsGrammarAccess getXbaseWithAnnotationsGrammarAccess() {
		return gaXbaseWithAnnotations;
	}

	
	////import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
	//// Language exists of Instructions
	//BotLanguage:
	//	{BotLanguage} instructions+=Instruction*;
	public BotLanguageElements getBotLanguageAccess() {
		return pBotLanguage;
	}
	
	public ParserRule getBotLanguageRule() {
		return getBotLanguageAccess().getRule();
	}

	//// The Bot Language contains 6 different instructions including variables
	//// loops, conditions, functons and the username and the password for the login
	//Instruction:
	//	Start | Stop | Procedure;
	public InstructionElements getInstructionAccess() {
		return pInstruction;
	}
	
	public ParserRule getInstructionRule() {
		return getInstructionAccess().getRule();
	}

	//// address for notification mails
	//Notification:
	//	{Notification} ("notify" | "Notify") name=STRING ("to" | "To" | "TO") address=STRING;
	public NotificationElements getNotificationAccess() {
		return pNotification;
	}
	
	public ParserRule getNotificationRule() {
		return getNotificationAccess().getRule();
	}

	//// Date evtl. mit parserrule anpassen  an Format
	//// Start for the time that starts the bot; user have to write the right form of the Type data
	//Start:
	//	{Start} ("start" | "Start" | "START") name=STRING;
	public StartElements getStartAccess() {
		return pStart;
	}
	
	public ParserRule getStartRule() {
		return getStartAccess().getRule();
	}

	//// Only stop; if the Stop implementation are read then stop the bot
	//Stop:
	//	{Stop} ("stop" | "Stop" | "STOP");
	public StopElements getStopAccess() {
		return pStop;
	}
	
	public ParserRule getStopRule() {
		return getStopAccess().getRule();
	}

	////DATE:
	////	day = DATE_FORMAT '.' month = DATE_FORMAT '.' year = YEAR ' ' hours = DATE_FORMAT ':' minutes = DATE_FORMAT ':' second = DATE_FORMAT
	////;
	////
	////
	//////
	////terminal DATE_FORMAT:
	////	(('0')('0'..'9')) | (('1'..'5')('0'..'9'))
	////;
	////
	////
	//////
	////terminal YEAR:
	////	('2'..'9')('0'..'9')('0'..'9')('0'..'9')
	////;
	//// Procedure to define the actions that the bot should do
	// Procedure:
	//	Connect | Read | Write | Click | Var | IFStatement | WhileLoop | Notification | Start | Stop | Wait;
	public ProcedureElements getProcedureAccess() {
		return pProcedure;
	}
	
	public ParserRule getProcedureRule() {
		return getProcedureAccess().getRule();
	}

	//// Wait for handle the click at's because bot action could be dedected if clicks are executed too fast
	// Wait:
	//	{Wait} ("wait" | "Wait") name=INT;
	public WaitElements getWaitAccess() {
		return pWait;
	}
	
	public ParserRule getWaitRule() {
		return getWaitAccess().getRule();
	}

	//// connecting with a URL
	//Connect:
	//	{Connect} ("connect" | "Connect") name= // URL 
	// STRING;
	public ConnectElements getConnectAccess() {
		return pConnect;
	}
	
	public ParserRule getConnectRule() {
		return getConnectAccess().getRule();
	}

	//// read at/from a X-Path statement 
	//Read:
	//	{Read} ("read at" | "readat" | "readAt" | "Read At" | "ReadAt") name= // XPath
	//	STRING;
	public ReadElements getReadAccess() {
		return pRead;
	}
	
	public ParserRule getReadRule() {
		return getReadAccess().getRule();
	}

	//// Write a value at a X-Path
	//Write:
	//	{Write} ("write" | "Write") name=STRING ("at" | "At" | "AT") value=STRING;
	public WriteElements getWriteAccess() {
		return pWrite;
	}
	
	public ParserRule getWriteRule() {
		return getWriteAccess().getRule();
	}

	//// Click at a X-Path
	//Click:
	//	{Click} ("click at" | "clickat" | "clickAt" | "Click At" | "ClickAt") name=STRING;
	public ClickElements getClickAccess() {
		return pClick;
	}
	
	public ParserRule getClickRule() {
		return getClickAccess().getRule();
	}

	//// A Variable for defining a ReadAt such as var a = read at 'xpath'
	//// It is comfortable for the user to use variables in if or while 
	//Var:
	//	{Var} ("var" | "Var" | "VAR") name=ID "=" value=Read;
	public VarElements getVarAccess() {
		return pVar;
	}
	
	public ParserRule getVarRule() {
		return getVarAccess().getRule();
	}

	//// If-statement for a normal if such as if ... else (optional) ... endif
	//IFStatement:
	//	("if" | "If" | "IF") if=IfExpression ("then" | "Then" | "THEN") then+=Block* (("else" | "Else" | "ELSE")
	//	else+=Block*)? ("endif" | "Endif" | "EndIf" | "ENDIF");
	public IFStatementElements getIFStatementAccess() {
		return pIFStatement;
	}
	
	public ParserRule getIFStatementRule() {
		return getIFStatementAccess().getRule();
	}

	//// Expression for a then-expression
	//Block:
	//	{Block} action=Write | Read | Click | Var | IFStatement | WhileLoop | Notification | Wait | Stop | Start;
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// begin of the IFExpression Rules including And-, Or- & Compare-Expressions to manage a right if statement
	//
	//IfExpression:
	//	IfAndExpression | IfOrExpression | IfCompareExpression;
	public IfExpressionElements getIfExpressionAccess() {
		return pIfExpression;
	}
	
	public ParserRule getIfExpressionRule() {
		return getIfExpressionAccess().getRule();
	}

	//// And
	// IfAndExpression:
	//	{IfAndExpression} leftFeature=IfCompareExpression and=andOperant rightFeature=IfExpression;
	public IfAndExpressionElements getIfAndExpressionAccess() {
		return pIfAndExpression;
	}
	
	public ParserRule getIfAndExpressionRule() {
		return getIfAndExpressionAccess().getRule();
	}

	////And
	// andOperant:
	//	"&&" | "&" | "and" | "And" | "AND";
	public AndOperantElements getAndOperantAccess() {
		return pAndOperant;
	}
	
	public ParserRule getAndOperantRule() {
		return getAndOperantAccess().getRule();
	}

	////OR
	// IfOrExpression:
	//	leftFeature=IfCompareExpression or=orOperant rightFeature=IfCompareExpression;
	public IfOrExpressionElements getIfOrExpressionAccess() {
		return pIfOrExpression;
	}
	
	public ParserRule getIfOrExpressionRule() {
		return getIfOrExpressionAccess().getRule();
	}

	////OR
	// orOperant:
	//	"||" | "|" | "or" | "Or" | "OR";
	public OrOperantElements getOrOperantAccess() {
		return pOrOperant;
	}
	
	public ParserRule getOrOperantRule() {
		return getOrOperantAccess().getRule();
	}

	////Compare
	// IfCompareExpression:
	//	leftFeature=CompareFeature compareOperant=MultiCompareOperant rightFeature=CompareValue;
	public IfCompareExpressionElements getIfCompareExpressionAccess() {
		return pIfCompareExpression;
	}
	
	public ParserRule getIfCompareExpressionRule() {
		return getIfCompareExpressionAccess().getRule();
	}

	////Compar
	// CompareValue:
	//	{CompareValue} INT | STRING | MathematicalInstructions | Read | variableValue=[Var];
	public CompareValueElements getCompareValueAccess() {
		return pCompareValue;
	}
	
	public ParserRule getCompareValueRule() {
		return getCompareValueAccess().getRule();
	}

	////Compare
	// MultiCompareOperant:
	//	"<" | "<=" | "==" | "=" | ">=" | ">" | "!=";
	public MultiCompareOperantElements getMultiCompareOperantAccess() {
		return pMultiCompareOperant;
	}
	
	public ParserRule getMultiCompareOperantRule() {
		return getMultiCompareOperantAccess().getRule();
	}

	////Compare
	// CompareFeature:
	//	{CompareFeature} INT | STRING | MathematicalInstructions | Read | variableFeature=[Var];
	public CompareFeatureElements getCompareFeatureAccess() {
		return pCompareFeature;
	}
	
	public ParserRule getCompareFeatureRule() {
		return getCompareFeatureAccess().getRule();
	}

	//// Mathematical Instructions
	//MathematicalInstructions:
	//	Addition | Subtraction | Multiplication | Division;
	public MathematicalInstructionsElements getMathematicalInstructionsAccess() {
		return pMathematicalInstructions;
	}
	
	public ParserRule getMathematicalInstructionsRule() {
		return getMathematicalInstructionsAccess().getRule();
	}

	////Add
	//Addition:
	//	{Addition} valueLeft=MathValue1 "+" valueRight=MathValue2;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	////Sub
	//Subtraction:
	//	{Subtraction} valueLeft=MathValue1 "-" valueRight=MathValue2;
	public SubtractionElements getSubtractionAccess() {
		return pSubtraction;
	}
	
	public ParserRule getSubtractionRule() {
		return getSubtractionAccess().getRule();
	}

	////Multiplicate
	//Multiplication:
	//	{Multiplication} valueLeft=MathValue1 "*" valueRight=MathValue2;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	////Divide
	//Division:
	//	{Division} valueLeft=MathValue1 "/" valueRight=MathValue2;
	public DivisionElements getDivisionAccess() {
		return pDivision;
	}
	
	public ParserRule getDivisionRule() {
		return getDivisionAccess().getRule();
	}

	////Mathematical Value almost left
	// MathValue1:
	//	{MathValue1} INT | Read | Var;
	public MathValue1Elements getMathValue1Access() {
		return pMathValue1;
	}
	
	public ParserRule getMathValue1Rule() {
		return getMathValue1Access().getRule();
	}

	////Mathematical Value almost right
	//MathValue2:
	//	{MathValue2} INT | Read | Var;
	public MathValue2Elements getMathValue2Access() {
		return pMathValue2;
	}
	
	public ParserRule getMathValue2Rule() {
		return getMathValue2Access().getRule();
	}

	//// While loop Statement for executing a loop with a IfExpression
	//WhileLoop:
	//	("while" | "While" | "WHILE") while=IfExpression ("loop" | "Loop" | "LOOP") doLoop+=Block* ("endloop" | "Endloop" |
	//	"EndLoop" | "ENDLOOP");
	public WhileLoopElements getWhileLoopAccess() {
		return pWhileLoop;
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}

	//XAnnotation:
	//	{XAnnotation} "@" annotationType=[types::JvmAnnotationType|QualifiedName] ("("
	//	(elementValuePairs+=XAnnotationElementValuePair ("," elementValuePairs+=XAnnotationElementValuePair)* |
	//	value=XAnnotationElementValueOrCommaList)? ")")?;
	public XbaseWithAnnotationsGrammarAccess.XAnnotationElements getXAnnotationAccess() {
		return gaXbaseWithAnnotations.getXAnnotationAccess();
	}
	
	public ParserRule getXAnnotationRule() {
		return getXAnnotationAccess().getRule();
	}

	//XAnnotationElementValuePair:
	//	=> (element=[types::JvmOperation|ValidID] "=") value=XAnnotationElementValue;
	public XbaseWithAnnotationsGrammarAccess.XAnnotationElementValuePairElements getXAnnotationElementValuePairAccess() {
		return gaXbaseWithAnnotations.getXAnnotationElementValuePairAccess();
	}
	
	public ParserRule getXAnnotationElementValuePairRule() {
		return getXAnnotationElementValuePairAccess().getRule();
	}

	//XAnnotationElementValueOrCommaList returns xbase::XExpression:
	//	=> ({xbase::XListLiteral} "#" "[") (elements+=XAnnotationOrExpression ("," elements+=XAnnotationOrExpression)*)? "]"
	//	| XAnnotationOrExpression ({xbase::XListLiteral.elements+=current} ("," elements+=XAnnotationOrExpression)+)?;
	public XbaseWithAnnotationsGrammarAccess.XAnnotationElementValueOrCommaListElements getXAnnotationElementValueOrCommaListAccess() {
		return gaXbaseWithAnnotations.getXAnnotationElementValueOrCommaListAccess();
	}
	
	public ParserRule getXAnnotationElementValueOrCommaListRule() {
		return getXAnnotationElementValueOrCommaListAccess().getRule();
	}

	//XAnnotationElementValue returns xbase::XExpression:
	//	=> ({xbase::XListLiteral} "#" "[") (elements+=XAnnotationOrExpression ("," elements+=XAnnotationOrExpression)*)? "]"
	//	| XAnnotationOrExpression;
	public XbaseWithAnnotationsGrammarAccess.XAnnotationElementValueElements getXAnnotationElementValueAccess() {
		return gaXbaseWithAnnotations.getXAnnotationElementValueAccess();
	}
	
	public ParserRule getXAnnotationElementValueRule() {
		return getXAnnotationElementValueAccess().getRule();
	}

	//XAnnotationOrExpression returns xbase::XExpression:
	//	XAnnotation | XExpression;
	public XbaseWithAnnotationsGrammarAccess.XAnnotationOrExpressionElements getXAnnotationOrExpressionAccess() {
		return gaXbaseWithAnnotations.getXAnnotationOrExpressionAccess();
	}
	
	public ParserRule getXAnnotationOrExpressionRule() {
		return getXAnnotationOrExpressionAccess().getRule();
	}

	//XExpression:
	//	XAssignment;
	public XbaseGrammarAccess.XExpressionElements getXExpressionAccess() {
		return gaXbaseWithAnnotations.getXExpressionAccess();
	}
	
	public ParserRule getXExpressionRule() {
		return getXExpressionAccess().getRule();
	}

	//XAssignment returns XExpression:
	//	{XAssignment} feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign value=XAssignment | XOrExpression
	//	(=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpMultiAssign])
	//	rightOperand=XAssignment)?;
	public XbaseGrammarAccess.XAssignmentElements getXAssignmentAccess() {
		return gaXbaseWithAnnotations.getXAssignmentAccess();
	}
	
	public ParserRule getXAssignmentRule() {
		return getXAssignmentAccess().getRule();
	}

	//OpSingleAssign:
	//	"=";
	public XbaseGrammarAccess.OpSingleAssignElements getOpSingleAssignAccess() {
		return gaXbaseWithAnnotations.getOpSingleAssignAccess();
	}
	
	public ParserRule getOpSingleAssignRule() {
		return getOpSingleAssignAccess().getRule();
	}

	//OpMultiAssign:
	//	"+=" | "-=" | "*=" | "/=" | "%=" | "<" "<" "=" | ">" ">"? ">=";
	public XbaseGrammarAccess.OpMultiAssignElements getOpMultiAssignAccess() {
		return gaXbaseWithAnnotations.getOpMultiAssignAccess();
	}
	
	public ParserRule getOpMultiAssignRule() {
		return getOpMultiAssignAccess().getRule();
	}

	//XOrExpression returns XExpression:
	//	XAndExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpOr])
	//	rightOperand=XAndExpression)*;
	public XbaseGrammarAccess.XOrExpressionElements getXOrExpressionAccess() {
		return gaXbaseWithAnnotations.getXOrExpressionAccess();
	}
	
	public ParserRule getXOrExpressionRule() {
		return getXOrExpressionAccess().getRule();
	}

	//OpOr:
	//	"||";
	public XbaseGrammarAccess.OpOrElements getOpOrAccess() {
		return gaXbaseWithAnnotations.getOpOrAccess();
	}
	
	public ParserRule getOpOrRule() {
		return getOpOrAccess().getRule();
	}

	//XAndExpression returns XExpression:
	//	XEqualityExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpAnd])
	//	rightOperand=XEqualityExpression)*;
	public XbaseGrammarAccess.XAndExpressionElements getXAndExpressionAccess() {
		return gaXbaseWithAnnotations.getXAndExpressionAccess();
	}
	
	public ParserRule getXAndExpressionRule() {
		return getXAndExpressionAccess().getRule();
	}

	//OpAnd:
	//	"&&";
	public XbaseGrammarAccess.OpAndElements getOpAndAccess() {
		return gaXbaseWithAnnotations.getOpAndAccess();
	}
	
	public ParserRule getOpAndRule() {
		return getOpAndAccess().getRule();
	}

	//XEqualityExpression returns XExpression:
	//	XRelationalExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpEquality])
	//	rightOperand=XRelationalExpression)*;
	public XbaseGrammarAccess.XEqualityExpressionElements getXEqualityExpressionAccess() {
		return gaXbaseWithAnnotations.getXEqualityExpressionAccess();
	}
	
	public ParserRule getXEqualityExpressionRule() {
		return getXEqualityExpressionAccess().getRule();
	}

	//OpEquality:
	//	"==" | "!=" | "===" | "!==";
	public XbaseGrammarAccess.OpEqualityElements getOpEqualityAccess() {
		return gaXbaseWithAnnotations.getOpEqualityAccess();
	}
	
	public ParserRule getOpEqualityRule() {
		return getOpEqualityAccess().getRule();
	}

	//XRelationalExpression returns XExpression:
	//	XOtherOperatorExpression (=> ({XInstanceOfExpression.expression=current} "instanceof") type=JvmTypeReference | =>
	//	({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpCompare])
	//	rightOperand=XOtherOperatorExpression)*;
	public XbaseGrammarAccess.XRelationalExpressionElements getXRelationalExpressionAccess() {
		return gaXbaseWithAnnotations.getXRelationalExpressionAccess();
	}
	
	public ParserRule getXRelationalExpressionRule() {
		return getXRelationalExpressionAccess().getRule();
	}

	//OpCompare:
	//	">=" | "<" "=" | ">" | "<";
	public XbaseGrammarAccess.OpCompareElements getOpCompareAccess() {
		return gaXbaseWithAnnotations.getOpCompareAccess();
	}
	
	public ParserRule getOpCompareRule() {
		return getOpCompareAccess().getRule();
	}

	//XOtherOperatorExpression returns XExpression:
	//	XAdditiveExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpOther])
	//	rightOperand=XAdditiveExpression)*;
	public XbaseGrammarAccess.XOtherOperatorExpressionElements getXOtherOperatorExpressionAccess() {
		return gaXbaseWithAnnotations.getXOtherOperatorExpressionAccess();
	}
	
	public ParserRule getXOtherOperatorExpressionRule() {
		return getXOtherOperatorExpressionAccess().getRule();
	}

	//OpOther:
	//	"->" | "..<" | ">" ".." | ".." | "=>" | ">" (=> (">" ">") | ">") | "<" (=> ("<" "<") | "<" | "=>") | "<>" | "?:";
	public XbaseGrammarAccess.OpOtherElements getOpOtherAccess() {
		return gaXbaseWithAnnotations.getOpOtherAccess();
	}
	
	public ParserRule getOpOtherRule() {
		return getOpOtherAccess().getRule();
	}

	//XAdditiveExpression returns XExpression:
	//	XMultiplicativeExpression (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpAdd])
	//	rightOperand=XMultiplicativeExpression)*;
	public XbaseGrammarAccess.XAdditiveExpressionElements getXAdditiveExpressionAccess() {
		return gaXbaseWithAnnotations.getXAdditiveExpressionAccess();
	}
	
	public ParserRule getXAdditiveExpressionRule() {
		return getXAdditiveExpressionAccess().getRule();
	}

	//OpAdd:
	//	"+" | "-";
	public XbaseGrammarAccess.OpAddElements getOpAddAccess() {
		return gaXbaseWithAnnotations.getOpAddAccess();
	}
	
	public ParserRule getOpAddRule() {
		return getOpAddAccess().getRule();
	}

	//XMultiplicativeExpression returns XExpression:
	//	XUnaryOperation (=> ({XBinaryOperation.leftOperand=current} feature=[types::JvmIdentifiableElement|OpMulti])
	//	rightOperand=XUnaryOperation)*;
	public XbaseGrammarAccess.XMultiplicativeExpressionElements getXMultiplicativeExpressionAccess() {
		return gaXbaseWithAnnotations.getXMultiplicativeExpressionAccess();
	}
	
	public ParserRule getXMultiplicativeExpressionRule() {
		return getXMultiplicativeExpressionAccess().getRule();
	}

	//OpMulti:
	//	"*" | "**" | "/" | "%";
	public XbaseGrammarAccess.OpMultiElements getOpMultiAccess() {
		return gaXbaseWithAnnotations.getOpMultiAccess();
	}
	
	public ParserRule getOpMultiRule() {
		return getOpMultiAccess().getRule();
	}

	//XUnaryOperation returns XExpression:
	//	{XUnaryOperation} feature=[types::JvmIdentifiableElement|OpUnary] operand=XUnaryOperation | XCastedExpression;
	public XbaseGrammarAccess.XUnaryOperationElements getXUnaryOperationAccess() {
		return gaXbaseWithAnnotations.getXUnaryOperationAccess();
	}
	
	public ParserRule getXUnaryOperationRule() {
		return getXUnaryOperationAccess().getRule();
	}

	//OpUnary:
	//	"!" | "-" | "+";
	public XbaseGrammarAccess.OpUnaryElements getOpUnaryAccess() {
		return gaXbaseWithAnnotations.getOpUnaryAccess();
	}
	
	public ParserRule getOpUnaryRule() {
		return getOpUnaryAccess().getRule();
	}

	//XCastedExpression returns XExpression:
	//	XPostfixOperation (=> ({XCastedExpression.target=current} "as") type=JvmTypeReference)*;
	public XbaseGrammarAccess.XCastedExpressionElements getXCastedExpressionAccess() {
		return gaXbaseWithAnnotations.getXCastedExpressionAccess();
	}
	
	public ParserRule getXCastedExpressionRule() {
		return getXCastedExpressionAccess().getRule();
	}

	//XPostfixOperation returns XExpression:
	//	XMemberFeatureCall => ({XPostfixOperation.operand=current} feature=[types::JvmIdentifiableElement|OpPostfix])?;
	public XbaseGrammarAccess.XPostfixOperationElements getXPostfixOperationAccess() {
		return gaXbaseWithAnnotations.getXPostfixOperationAccess();
	}
	
	public ParserRule getXPostfixOperationRule() {
		return getXPostfixOperationAccess().getRule();
	}

	//OpPostfix:
	//	"++" | "--";
	public XbaseGrammarAccess.OpPostfixElements getOpPostfixAccess() {
		return gaXbaseWithAnnotations.getOpPostfixAccess();
	}
	
	public ParserRule getOpPostfixRule() {
		return getOpPostfixAccess().getRule();
	}

	//XMemberFeatureCall returns XExpression:
	//	XPrimaryExpression (=> ({XAssignment.assignable=current} ("." | explicitStatic?="::")
	//	feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign) value=XAssignment | =>
	//	({XMemberFeatureCall.memberCallTarget=current} ("." | nullSafe?="?." | explicitStatic?="::")) ("<"
	//	typeArguments+=JvmArgumentTypeReference ("," typeArguments+=JvmArgumentTypeReference)* ">")?
	//	feature=[types::JvmIdentifiableElement|IdOrSuper] (=> explicitOperationCall?="(" (memberCallArguments+=XShortClosure
	//	| memberCallArguments+=XExpression ("," memberCallArguments+=XExpression)*)? ")")? memberCallArguments+=XClosure?)*;
	public XbaseGrammarAccess.XMemberFeatureCallElements getXMemberFeatureCallAccess() {
		return gaXbaseWithAnnotations.getXMemberFeatureCallAccess();
	}
	
	public ParserRule getXMemberFeatureCallRule() {
		return getXMemberFeatureCallAccess().getRule();
	}

	//XPrimaryExpression returns XExpression:
	//	XConstructorCall | XBlockExpression | XSwitchExpression | XSynchronizedExpression | XFeatureCall | XLiteral |
	//	XIfExpression | XForLoopExpression | XBasicForLoopExpression | XWhileExpression | XDoWhileExpression |
	//	XThrowExpression | XReturnExpression | XTryCatchFinallyExpression | XParenthesizedExpression;
	public XbaseGrammarAccess.XPrimaryExpressionElements getXPrimaryExpressionAccess() {
		return gaXbaseWithAnnotations.getXPrimaryExpressionAccess();
	}
	
	public ParserRule getXPrimaryExpressionRule() {
		return getXPrimaryExpressionAccess().getRule();
	}

	//XLiteral returns XExpression:
	//	XCollectionLiteral | XClosure | XBooleanLiteral | XNumberLiteral | XNullLiteral | XStringLiteral | XTypeLiteral;
	public XbaseGrammarAccess.XLiteralElements getXLiteralAccess() {
		return gaXbaseWithAnnotations.getXLiteralAccess();
	}
	
	public ParserRule getXLiteralRule() {
		return getXLiteralAccess().getRule();
	}

	//XCollectionLiteral:
	//	XSetLiteral | XListLiteral;
	public XbaseGrammarAccess.XCollectionLiteralElements getXCollectionLiteralAccess() {
		return gaXbaseWithAnnotations.getXCollectionLiteralAccess();
	}
	
	public ParserRule getXCollectionLiteralRule() {
		return getXCollectionLiteralAccess().getRule();
	}

	//XSetLiteral:
	//	{XSetLiteral} "#" "{" (elements+=XExpression ("," elements+=XExpression)*)? "}";
	public XbaseGrammarAccess.XSetLiteralElements getXSetLiteralAccess() {
		return gaXbaseWithAnnotations.getXSetLiteralAccess();
	}
	
	public ParserRule getXSetLiteralRule() {
		return getXSetLiteralAccess().getRule();
	}

	//XListLiteral:
	//	{XListLiteral} "#" "[" (elements+=XExpression ("," elements+=XExpression)*)? "]";
	public XbaseGrammarAccess.XListLiteralElements getXListLiteralAccess() {
		return gaXbaseWithAnnotations.getXListLiteralAccess();
	}
	
	public ParserRule getXListLiteralRule() {
		return getXListLiteralAccess().getRule();
	}

	//XClosure returns XExpression:
	//	=> ({XClosure} "[") => ((declaredFormalParameters+=JvmFormalParameter (","
	//	declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?="|")? expression=XExpressionInClosure "]";
	public XbaseGrammarAccess.XClosureElements getXClosureAccess() {
		return gaXbaseWithAnnotations.getXClosureAccess();
	}
	
	public ParserRule getXClosureRule() {
		return getXClosureAccess().getRule();
	}

	//XExpressionInClosure returns XExpression:
	//	{XBlockExpression} (expressions+=XExpressionOrVarDeclaration ";"?)*;
	public XbaseGrammarAccess.XExpressionInClosureElements getXExpressionInClosureAccess() {
		return gaXbaseWithAnnotations.getXExpressionInClosureAccess();
	}
	
	public ParserRule getXExpressionInClosureRule() {
		return getXExpressionInClosureAccess().getRule();
	}

	//XShortClosure returns XExpression:
	//	=> ({XClosure} (declaredFormalParameters+=JvmFormalParameter ("," declaredFormalParameters+=JvmFormalParameter)*)?
	//	explicitSyntax?="|") expression=XExpression;
	public XbaseGrammarAccess.XShortClosureElements getXShortClosureAccess() {
		return gaXbaseWithAnnotations.getXShortClosureAccess();
	}
	
	public ParserRule getXShortClosureRule() {
		return getXShortClosureAccess().getRule();
	}

	//XParenthesizedExpression returns XExpression:
	//	"(" XExpression ")";
	public XbaseGrammarAccess.XParenthesizedExpressionElements getXParenthesizedExpressionAccess() {
		return gaXbaseWithAnnotations.getXParenthesizedExpressionAccess();
	}
	
	public ParserRule getXParenthesizedExpressionRule() {
		return getXParenthesizedExpressionAccess().getRule();
	}

	//XIfExpression returns XExpression:
	//	{XIfExpression} "if" "(" if=XExpression ")" then=XExpression ("else" else=XExpression)?;
	public XbaseGrammarAccess.XIfExpressionElements getXIfExpressionAccess() {
		return gaXbaseWithAnnotations.getXIfExpressionAccess();
	}
	
	public ParserRule getXIfExpressionRule() {
		return getXIfExpressionAccess().getRule();
	}

	//XSwitchExpression returns XExpression:
	//	{XSwitchExpression} "switch" (=> ("(" declaredParam=JvmFormalParameter ":") switch=XExpression ")" | =>
	//	(declaredParam=JvmFormalParameter ":")? switch=XExpression) "{" cases+=XCasePart* ("default" ":"
	//	default=XExpression)? "}";
	public XbaseGrammarAccess.XSwitchExpressionElements getXSwitchExpressionAccess() {
		return gaXbaseWithAnnotations.getXSwitchExpressionAccess();
	}
	
	public ParserRule getXSwitchExpressionRule() {
		return getXSwitchExpressionAccess().getRule();
	}

	//XCasePart:
	//	{XCasePart} typeGuard=JvmTypeReference? ("case" case=XExpression)? (":" then=XExpression | fallThrough?=",");
	public XbaseGrammarAccess.XCasePartElements getXCasePartAccess() {
		return gaXbaseWithAnnotations.getXCasePartAccess();
	}
	
	public ParserRule getXCasePartRule() {
		return getXCasePartAccess().getRule();
	}

	//XForLoopExpression returns XExpression:
	//	=> ({XForLoopExpression} "for" "(" declaredParam=JvmFormalParameter ":") forExpression=XExpression ")"
	//	eachExpression=XExpression;
	public XbaseGrammarAccess.XForLoopExpressionElements getXForLoopExpressionAccess() {
		return gaXbaseWithAnnotations.getXForLoopExpressionAccess();
	}
	
	public ParserRule getXForLoopExpressionRule() {
		return getXForLoopExpressionAccess().getRule();
	}

	//XBasicForLoopExpression returns XExpression:
	//	{XBasicForLoopExpression} "for" "(" (initExpressions+=XExpressionOrVarDeclaration (","
	//	initExpressions+=XExpressionOrVarDeclaration)*)? ";" expression=XExpression? ";" (updateExpressions+=XExpression (","
	//	updateExpressions+=XExpression)*)? ")" eachExpression=XExpression;
	public XbaseGrammarAccess.XBasicForLoopExpressionElements getXBasicForLoopExpressionAccess() {
		return gaXbaseWithAnnotations.getXBasicForLoopExpressionAccess();
	}
	
	public ParserRule getXBasicForLoopExpressionRule() {
		return getXBasicForLoopExpressionAccess().getRule();
	}

	//XWhileExpression returns XExpression:
	//	{XWhileExpression} "while" "(" predicate=XExpression ")" body=XExpression;
	public XbaseGrammarAccess.XWhileExpressionElements getXWhileExpressionAccess() {
		return gaXbaseWithAnnotations.getXWhileExpressionAccess();
	}
	
	public ParserRule getXWhileExpressionRule() {
		return getXWhileExpressionAccess().getRule();
	}

	//XDoWhileExpression returns XExpression:
	//	{XDoWhileExpression} "do" body=XExpression "while" "(" predicate=XExpression ")";
	public XbaseGrammarAccess.XDoWhileExpressionElements getXDoWhileExpressionAccess() {
		return gaXbaseWithAnnotations.getXDoWhileExpressionAccess();
	}
	
	public ParserRule getXDoWhileExpressionRule() {
		return getXDoWhileExpressionAccess().getRule();
	}

	//XBlockExpression returns XExpression:
	//	{XBlockExpression} "{" (expressions+=XExpressionOrVarDeclaration ";"?)* "}";
	public XbaseGrammarAccess.XBlockExpressionElements getXBlockExpressionAccess() {
		return gaXbaseWithAnnotations.getXBlockExpressionAccess();
	}
	
	public ParserRule getXBlockExpressionRule() {
		return getXBlockExpressionAccess().getRule();
	}

	//XExpressionOrVarDeclaration returns XExpression:
	//	XVariableDeclaration | XExpression;
	public XbaseGrammarAccess.XExpressionOrVarDeclarationElements getXExpressionOrVarDeclarationAccess() {
		return gaXbaseWithAnnotations.getXExpressionOrVarDeclarationAccess();
	}
	
	public ParserRule getXExpressionOrVarDeclarationRule() {
		return getXExpressionOrVarDeclarationAccess().getRule();
	}

	//XVariableDeclaration returns XExpression:
	//	{XVariableDeclaration} (writeable?="var" | "val") (=> (type=JvmTypeReference name=ValidID) | name=ValidID) ("="
	//	right=XExpression)?;
	public XbaseGrammarAccess.XVariableDeclarationElements getXVariableDeclarationAccess() {
		return gaXbaseWithAnnotations.getXVariableDeclarationAccess();
	}
	
	public ParserRule getXVariableDeclarationRule() {
		return getXVariableDeclarationAccess().getRule();
	}

	//JvmFormalParameter returns types::JvmFormalParameter:
	//	parameterType=JvmTypeReference? name=ValidID;
	public XbaseGrammarAccess.JvmFormalParameterElements getJvmFormalParameterAccess() {
		return gaXbaseWithAnnotations.getJvmFormalParameterAccess();
	}
	
	public ParserRule getJvmFormalParameterRule() {
		return getJvmFormalParameterAccess().getRule();
	}

	//FullJvmFormalParameter returns types::JvmFormalParameter:
	//	parameterType=JvmTypeReference name=ValidID;
	public XbaseGrammarAccess.FullJvmFormalParameterElements getFullJvmFormalParameterAccess() {
		return gaXbaseWithAnnotations.getFullJvmFormalParameterAccess();
	}
	
	public ParserRule getFullJvmFormalParameterRule() {
		return getFullJvmFormalParameterAccess().getRule();
	}

	//XFeatureCall returns XExpression:
	//	{XFeatureCall} ("<" typeArguments+=JvmArgumentTypeReference ("," typeArguments+=JvmArgumentTypeReference)* ">")?
	//	feature=[types::JvmIdentifiableElement|IdOrSuper] (=> explicitOperationCall?="(" (featureCallArguments+=XShortClosure
	//	| featureCallArguments+=XExpression ("," featureCallArguments+=XExpression)*)? ")")? featureCallArguments+=XClosure?;
	public XbaseGrammarAccess.XFeatureCallElements getXFeatureCallAccess() {
		return gaXbaseWithAnnotations.getXFeatureCallAccess();
	}
	
	public ParserRule getXFeatureCallRule() {
		return getXFeatureCallAccess().getRule();
	}

	//FeatureCallID:
	//	ValidID | "extends" | "static" | "import" | "extension";
	public XbaseGrammarAccess.FeatureCallIDElements getFeatureCallIDAccess() {
		return gaXbaseWithAnnotations.getFeatureCallIDAccess();
	}
	
	public ParserRule getFeatureCallIDRule() {
		return getFeatureCallIDAccess().getRule();
	}

	//IdOrSuper:
	//	FeatureCallID | "super";
	public XbaseGrammarAccess.IdOrSuperElements getIdOrSuperAccess() {
		return gaXbaseWithAnnotations.getIdOrSuperAccess();
	}
	
	public ParserRule getIdOrSuperRule() {
		return getIdOrSuperAccess().getRule();
	}

	//XConstructorCall returns XExpression:
	//	{XConstructorCall} "new" constructor=[types::JvmConstructor|QualifiedName] ("<"
	//	typeArguments+=JvmArgumentTypeReference ("," typeArguments+=JvmArgumentTypeReference)* ">")? (=>
	//	explicitConstructorCall?="(" (arguments+=XShortClosure | arguments+=XExpression ("," arguments+=XExpression)*)? ")")?
	//	arguments+=XClosure?;
	public XbaseGrammarAccess.XConstructorCallElements getXConstructorCallAccess() {
		return gaXbaseWithAnnotations.getXConstructorCallAccess();
	}
	
	public ParserRule getXConstructorCallRule() {
		return getXConstructorCallAccess().getRule();
	}

	//XBooleanLiteral returns XExpression:
	//	{XBooleanLiteral} ("false" | isTrue?="true");
	public XbaseGrammarAccess.XBooleanLiteralElements getXBooleanLiteralAccess() {
		return gaXbaseWithAnnotations.getXBooleanLiteralAccess();
	}
	
	public ParserRule getXBooleanLiteralRule() {
		return getXBooleanLiteralAccess().getRule();
	}

	//XNullLiteral returns XExpression:
	//	{XNullLiteral} "null";
	public XbaseGrammarAccess.XNullLiteralElements getXNullLiteralAccess() {
		return gaXbaseWithAnnotations.getXNullLiteralAccess();
	}
	
	public ParserRule getXNullLiteralRule() {
		return getXNullLiteralAccess().getRule();
	}

	//XNumberLiteral returns XExpression:
	//	{XNumberLiteral} value=Number;
	public XbaseGrammarAccess.XNumberLiteralElements getXNumberLiteralAccess() {
		return gaXbaseWithAnnotations.getXNumberLiteralAccess();
	}
	
	public ParserRule getXNumberLiteralRule() {
		return getXNumberLiteralAccess().getRule();
	}

	//XStringLiteral returns XExpression:
	//	{XStringLiteral} value=STRING;
	public XbaseGrammarAccess.XStringLiteralElements getXStringLiteralAccess() {
		return gaXbaseWithAnnotations.getXStringLiteralAccess();
	}
	
	public ParserRule getXStringLiteralRule() {
		return getXStringLiteralAccess().getRule();
	}

	//XTypeLiteral returns XExpression:
	//	{XTypeLiteral} "typeof" "(" type=[types::JvmType|QualifiedName] arrayDimensions+=ArrayBrackets* ")";
	public XbaseGrammarAccess.XTypeLiteralElements getXTypeLiteralAccess() {
		return gaXbaseWithAnnotations.getXTypeLiteralAccess();
	}
	
	public ParserRule getXTypeLiteralRule() {
		return getXTypeLiteralAccess().getRule();
	}

	//XThrowExpression returns XExpression:
	//	{XThrowExpression} "throw" expression=XExpression;
	public XbaseGrammarAccess.XThrowExpressionElements getXThrowExpressionAccess() {
		return gaXbaseWithAnnotations.getXThrowExpressionAccess();
	}
	
	public ParserRule getXThrowExpressionRule() {
		return getXThrowExpressionAccess().getRule();
	}

	//XReturnExpression returns XExpression:
	//	{XReturnExpression} "return" -> expression=XExpression?;
	public XbaseGrammarAccess.XReturnExpressionElements getXReturnExpressionAccess() {
		return gaXbaseWithAnnotations.getXReturnExpressionAccess();
	}
	
	public ParserRule getXReturnExpressionRule() {
		return getXReturnExpressionAccess().getRule();
	}

	//XTryCatchFinallyExpression returns XExpression:
	//	{XTryCatchFinallyExpression} "try" expression=XExpression (catchClauses+=XCatchClause+ ("finally"
	//	finallyExpression=XExpression)? | "finally" finallyExpression=XExpression);
	public XbaseGrammarAccess.XTryCatchFinallyExpressionElements getXTryCatchFinallyExpressionAccess() {
		return gaXbaseWithAnnotations.getXTryCatchFinallyExpressionAccess();
	}
	
	public ParserRule getXTryCatchFinallyExpressionRule() {
		return getXTryCatchFinallyExpressionAccess().getRule();
	}

	//XSynchronizedExpression returns XExpression:
	//	=> ({XSynchronizedExpression} "synchronized" "(") param=XExpression ")" expression=XExpression;
	public XbaseGrammarAccess.XSynchronizedExpressionElements getXSynchronizedExpressionAccess() {
		return gaXbaseWithAnnotations.getXSynchronizedExpressionAccess();
	}
	
	public ParserRule getXSynchronizedExpressionRule() {
		return getXSynchronizedExpressionAccess().getRule();
	}

	//XCatchClause:
	//	"catch" "(" declaredParam=FullJvmFormalParameter ")" expression=XExpression;
	public XbaseGrammarAccess.XCatchClauseElements getXCatchClauseAccess() {
		return gaXbaseWithAnnotations.getXCatchClauseAccess();
	}
	
	public ParserRule getXCatchClauseRule() {
		return getXCatchClauseAccess().getRule();
	}

	//QualifiedName:
	//	ValidID ("." ValidID)*;
	public XbaseGrammarAccess.QualifiedNameElements getQualifiedNameAccess() {
		return gaXbaseWithAnnotations.getQualifiedNameAccess();
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//Number hidden():
	//	HEX | (INT | DECIMAL) ("." (INT | DECIMAL))?;
	public XbaseGrammarAccess.NumberElements getNumberAccess() {
		return gaXbaseWithAnnotations.getNumberAccess();
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}

	/// **
	// * Dummy rule, for "better" downwards compatibility, since GrammarAccess generates non-static inner classes, 
	// * which makes downstream grammars break on classloading, when a rule is removed.
	// * /
	//StaticQualifier:
	//	(ValidID "::")+;
	public XbaseGrammarAccess.StaticQualifierElements getStaticQualifierAccess() {
		return gaXbaseWithAnnotations.getStaticQualifierAccess();
	}
	
	public ParserRule getStaticQualifierRule() {
		return getStaticQualifierAccess().getRule();
	}

	//terminal HEX:
	//	("0x" | "0X") ("0".."9" | "a".."f" | "A".."F" | "_")+ ("#" (("b" | "B") ("i" | "I") | ("l" | "L")))?;
	public TerminalRule getHEXRule() {
		return gaXbaseWithAnnotations.getHEXRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9" ("0".."9" | "_")*;
	public TerminalRule getINTRule() {
		return gaXbaseWithAnnotations.getINTRule();
	} 

	//terminal DECIMAL:
	//	INT (("e" | "E") ("+" | "-")? INT)? (("b" | "B") ("i" | "I" | "d" | "D") | ("l" | "L" | "d" | "D" | "f" | "F"))?;
	public TerminalRule getDECIMALRule() {
		return gaXbaseWithAnnotations.getDECIMALRule();
	} 

	//JvmTypeReference:
	//	JvmParameterizedTypeReference => ({JvmGenericArrayTypeReference.componentType=current} ArrayBrackets)* |
	//	XFunctionTypeRef;
	public XtypeGrammarAccess.JvmTypeReferenceElements getJvmTypeReferenceAccess() {
		return gaXbaseWithAnnotations.getJvmTypeReferenceAccess();
	}
	
	public ParserRule getJvmTypeReferenceRule() {
		return getJvmTypeReferenceAccess().getRule();
	}

	//ArrayBrackets:
	//	"[" "]";
	public XtypeGrammarAccess.ArrayBracketsElements getArrayBracketsAccess() {
		return gaXbaseWithAnnotations.getArrayBracketsAccess();
	}
	
	public ParserRule getArrayBracketsRule() {
		return getArrayBracketsAccess().getRule();
	}

	//XFunctionTypeRef:
	//	("(" (paramTypes+=JvmTypeReference ("," paramTypes+=JvmTypeReference)*)? ")")? "=>" returnType=JvmTypeReference;
	public XtypeGrammarAccess.XFunctionTypeRefElements getXFunctionTypeRefAccess() {
		return gaXbaseWithAnnotations.getXFunctionTypeRefAccess();
	}
	
	public ParserRule getXFunctionTypeRefRule() {
		return getXFunctionTypeRefAccess().getRule();
	}

	//JvmParameterizedTypeReference:
	//	type=[JvmType|QualifiedName] ("<" arguments+=JvmArgumentTypeReference ("," arguments+=JvmArgumentTypeReference)* ">"
	//	(=> ({JvmInnerTypeReference.outer=current} ".") type=[JvmType|ValidID] ("<" arguments+=JvmArgumentTypeReference (","
	//	arguments+=JvmArgumentTypeReference)* ">")?)*)?;
	public XtypeGrammarAccess.JvmParameterizedTypeReferenceElements getJvmParameterizedTypeReferenceAccess() {
		return gaXbaseWithAnnotations.getJvmParameterizedTypeReferenceAccess();
	}
	
	public ParserRule getJvmParameterizedTypeReferenceRule() {
		return getJvmParameterizedTypeReferenceAccess().getRule();
	}

	//JvmArgumentTypeReference returns JvmTypeReference:
	//	JvmTypeReference | JvmWildcardTypeReference;
	public XtypeGrammarAccess.JvmArgumentTypeReferenceElements getJvmArgumentTypeReferenceAccess() {
		return gaXbaseWithAnnotations.getJvmArgumentTypeReferenceAccess();
	}
	
	public ParserRule getJvmArgumentTypeReferenceRule() {
		return getJvmArgumentTypeReferenceAccess().getRule();
	}

	//JvmWildcardTypeReference:
	//	{JvmWildcardTypeReference} "?" (constraints+=JvmUpperBound constraints+=JvmUpperBoundAnded* |
	//	constraints+=JvmLowerBound constraints+=JvmLowerBoundAnded*)?;
	public XtypeGrammarAccess.JvmWildcardTypeReferenceElements getJvmWildcardTypeReferenceAccess() {
		return gaXbaseWithAnnotations.getJvmWildcardTypeReferenceAccess();
	}
	
	public ParserRule getJvmWildcardTypeReferenceRule() {
		return getJvmWildcardTypeReferenceAccess().getRule();
	}

	//JvmUpperBound:
	//	"extends" typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmUpperBoundElements getJvmUpperBoundAccess() {
		return gaXbaseWithAnnotations.getJvmUpperBoundAccess();
	}
	
	public ParserRule getJvmUpperBoundRule() {
		return getJvmUpperBoundAccess().getRule();
	}

	//JvmUpperBoundAnded returns JvmUpperBound:
	//	"&" typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmUpperBoundAndedElements getJvmUpperBoundAndedAccess() {
		return gaXbaseWithAnnotations.getJvmUpperBoundAndedAccess();
	}
	
	public ParserRule getJvmUpperBoundAndedRule() {
		return getJvmUpperBoundAndedAccess().getRule();
	}

	//JvmLowerBound:
	//	"super" typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmLowerBoundElements getJvmLowerBoundAccess() {
		return gaXbaseWithAnnotations.getJvmLowerBoundAccess();
	}
	
	public ParserRule getJvmLowerBoundRule() {
		return getJvmLowerBoundAccess().getRule();
	}

	//JvmLowerBoundAnded returns JvmLowerBound:
	//	"&" typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmLowerBoundAndedElements getJvmLowerBoundAndedAccess() {
		return gaXbaseWithAnnotations.getJvmLowerBoundAndedAccess();
	}
	
	public ParserRule getJvmLowerBoundAndedRule() {
		return getJvmLowerBoundAndedAccess().getRule();
	}

	//JvmTypeParameter:
	//	name=ValidID (constraints+=JvmUpperBound constraints+=JvmUpperBoundAnded*)?;
	public XtypeGrammarAccess.JvmTypeParameterElements getJvmTypeParameterAccess() {
		return gaXbaseWithAnnotations.getJvmTypeParameterAccess();
	}
	
	public ParserRule getJvmTypeParameterRule() {
		return getJvmTypeParameterAccess().getRule();
	}

	//QualifiedNameWithWildcard:
	//	QualifiedName "." "*";
	public XtypeGrammarAccess.QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return gaXbaseWithAnnotations.getQualifiedNameWithWildcardAccess();
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}

	//ValidID:
	//	ID;
	public XtypeGrammarAccess.ValidIDElements getValidIDAccess() {
		return gaXbaseWithAnnotations.getValidIDAccess();
	}
	
	public ParserRule getValidIDRule() {
		return getValidIDAccess().getRule();
	}

	//XImportSection:
	//	importDeclarations+=XImportDeclaration+;
	public XtypeGrammarAccess.XImportSectionElements getXImportSectionAccess() {
		return gaXbaseWithAnnotations.getXImportSectionAccess();
	}
	
	public ParserRule getXImportSectionRule() {
		return getXImportSectionAccess().getRule();
	}

	//XImportDeclaration:
	//	"import" (static?="static" extension?="extension"? importedType=[JvmDeclaredType|QualifiedNameInStaticImport]
	//	(wildcard?="*" | memberName=ValidID) | importedType=[JvmDeclaredType|QualifiedName] |
	//	importedNamespace=QualifiedNameWithWildcard) ";"?;
	public XtypeGrammarAccess.XImportDeclarationElements getXImportDeclarationAccess() {
		return gaXbaseWithAnnotations.getXImportDeclarationAccess();
	}
	
	public ParserRule getXImportDeclarationRule() {
		return getXImportDeclarationAccess().getRule();
	}

	//QualifiedNameInStaticImport:
	//	(ValidID ".")+;
	public XtypeGrammarAccess.QualifiedNameInStaticImportElements getQualifiedNameInStaticImportAccess() {
		return gaXbaseWithAnnotations.getQualifiedNameInStaticImportAccess();
	}
	
	public ParserRule getQualifiedNameInStaticImportRule() {
		return getQualifiedNameInStaticImportAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "$" | "_") ("a".."z" | "A".."Z" | "$" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaXbaseWithAnnotations.getIDRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') * / | !("\\" | "\""))* "\""? | "\'" ("\\" .
	//	/ * ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') * / | !("\\" | "\'"))* "\'"?;
	public TerminalRule getSTRINGRule() {
		return gaXbaseWithAnnotations.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaXbaseWithAnnotations.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaXbaseWithAnnotations.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaXbaseWithAnnotations.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaXbaseWithAnnotations.getANY_OTHERRule();
	} 
}
